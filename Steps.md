## Steps
### Step 1 -- Creating first FLTK project and building
Create a new project in Code::Blocks and use the 'FLTK project' template. Use proper project name. On the next window select the button next to the FLTK's location text box. Close the window which appears with a lot of text boxes and buttons. It will ask if you want to save invalid value for the variables, click 'no'. A file browser will appear, select the fltk folder, example 'D:/fltk-1.3.4-1'. Click on next. Use the 'simple main() example' and click on next. Finish the wizard.  
There will be some code automatically generated by Code::Blocks which can be seen in sources->main.cpp. The code in this repository has been commented to explain each line. You can easily see how easy and intuitive hello world in FLTK code looks. A window is created, then a box is created to display something on the window. Different properties of the box are then set. Then finally we make the window appear and transfer the control to FLTK which will exit when the window is closed.  
The only magical portion here can be that we never added `box` to `window` but fltk automatically did that. It is because whenever we create widgets which can contain other widgets, they are set as current grouping widgets. Then whenever we create some other widget, it is automatically added to current grouping widget. Hence we need to call `window->end()` to tell fltk not to add any more widgets to window.  
Feel free to google about other GUI APIs for C++ and look at their hello world programs. Then you can actually see how much effort we saved by using FLTK for this project. Happy Coding! :)  

### Step 2 -- Create basic GUI and menu bar
We will create 4 buttons and a box in this tutorial. The box will be used to display the image and the buttons will be used to switch images, zoom or delete an image file. We also created Menu bar which can be used later for opening images. Most of the code is explained in comments. As it can be seen, FLTK relies heavily on callbacks, like most of the GUI libraries. So we need to make callback functions for every function. When a widget is invoked/clicked it calls the callback function which can do the required work.  
Also, there was one error in comments of the previous commit, it was mentioned that the starting 4 paramters to constructor of Box are coordinates of top left corner and bottom right corner of the box. But the first two parameters are coordinates of top left corner and the later two parameters are width and height of the box respectively. Sorry for the error.  
In this step, we see how intuitive and functions based model FLTK is. This simplicity comes with a slight price that the GUI from FLTK is not so nice looking. But for beginning GUI programming simplicity should be given more importance. Once you have mastered FLTK, learning other more complicated GUI libraries will become quite easier (either on your own or from upcoming OWPs).  

### Step 3 -- Opening and image from file dialog box
In this step, we create utilities.h and utilities.cpp files and add a function which loads an image from file path. The code is self explanatory with some comments. We also make our image box global and change the image on it in the `open_cb` callback. The code has been explained in comments. We need to redraw the image box after changing the image as, like all GUI APIs, fltk avoids redrawing everything to reduce unnecessary overload. In the next step we will add a list to our program and let the user view all the files from a certain directory rather than just a single image.  
This step is small, you can use fltk documentation to view all the FLTK classes and functions and how to use them.  

### Step 4 -- Navigating a list of images and delting images
In this step we add one more menu item to open a directory. All the images present in the directory will be read by the utility function `populate_image_filenames` which we will create in our utilities header. We will also add callback for all the 4 buttons for previous, next, delete and zoom operations. We also implement the callbacks for the first 3 operations. The first two operations simply involve nagivating forward/backward in the list. For deleting we will use standard C++ function `remove` from stdio. Also, we have changed the code so all available files are stored in a vector of strings. `c_str()` function is used a lot as it returns `char*` for the string which is required for many fltk functions. Also, when user opens one file, we simply clear the list and add that one file to the list.  
There are many comments to explain the code. If something is not clear, feel free to open and issue on this repo. As mentioned earlier, you can learn more about fltk functions from their docs. Happy Coding! :)  

### Step 5 -- Handle resize & add icons to buttons
In this step we will make our image viewer look better. Till now, it looked very bad on any standards, but now, lets replace all the text on buttons by icons. We will use 4 transparent background images for the 4 buttons. Also, lets place the previous and next buttons on the side of the image. We will also set 'a' and 'd' keys to be shortcut for the previous and next buttons respectively.  
Till now our window is fixed size, we will make the image area resizable by calling `window->resizable(image_box);`. But, after this you can see that the image won't be properly drawn and even after resizing everything will be messed up. The problem is we don't know the new size of the window and `update_current_image` is not being called on resize. Since, FLTK does not allow a resize/redraw handler, we will make a subclass of Fl_Window and name it `Ex_Fl_Window` for Extentended Fl_Window. We will override the draw function only, as that is the only function required. We will store a functor (function pointer) in our class which will be called on every draw before calling the base class' draw function to actually draw every widget. The `update_current_image` function is then set in `set_cb` and we call it whenever window is drawn. At every resize, the window is redraw, so we have handled that situation as well.  
Our Image Viewer is finally looking a lot better and promising. We just have to add the zoom functionality and we are done! We'll do it in the next step. Most of the code is explained in the comments. And again, google/issues are available at your disposal. Happy Coding! :)  

### Step 6
Coming Soon...
